<!doctype html>
<html lang='en'>
  <head>
    <meta name='twitter:card' content='summary' />
    <meta property='og:title' content='Reading from the Command-Line in Kotlin' />
    <meta property='og:url' content='https://seansoper.com/blog/reading_command_line.html' />
    <meta property='og:description' content='When it comes to breaking down complex problems into smaller ones Kotlin offers a full range of functional tools and patterns to make your job easier. Building on our previous entry around building a command-line application we will put several techniques to use to build a robust solution to the problem of accepting and validating user input.' />
    <meta property='og:image' content='//source.unsplash.com/uZqJVqwFxMQ/1200x627' />
    <!-- Generated by zebec https://github.com/ssoper/Zebec -->
    <meta charset='utf-8' />
    <meta http-equiv='X-UA-Compatible' content='IE=edge' />
    <meta name='viewport' content='width=device-width, initial-scale=1, shrink-to-fit=no' />
    <meta name='ICBM' content='39.0840, 77.1528' />
    <title>eat. code. stocks.</title>
    <link type='image/x-icon' href='/favicon.ico' rel='shortcut icon' />
    <link type='application/rss+xml' title='eat. code. stocks.' href='/blog/rss.xml' rel='alternate' />
    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src='https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js'></script>
      <script src='https://oss.maxcdn.com/respond/1.4.2/respond.min.js'></script>
    <![endif]-->
  </head>
  <body>
    <!-- Navigation -->
    <nav class='navbar navbar-expand-lg navbar-dark bg-dark fixed-top'>
      <div class='container'>
        <a class='navbar-brand' title='eat. code. stocks.' href='/blog'>üç± üë®üèª‚Äçüíª üè¶</a>
        <button class='navbar-toggler' type='button' data-toggle='collapse' data-target='#navbarResponsive' aria-controls='navbarResponsive' aria-expanded='false' aria-label='Toggle navigation'>
          <span class='navbar-toggler-icon'></span>
        </button>
        <div class='collapse navbar-collapse' id='navbarResponsive'>
          <ul class='navbar-nav ml-auto'>
            <li class='nav-item'>
              <a class='nav-link' href='/'>Home</a>
            </li>
            <li class='nav-item'>
              <a class='nav-link' href='/blog'>Blog</a>
            </li>
          </ul>
        </div>
      </div>
    </nav>
    <!-- Page Content -->
    <div class='container'>
      <div class='row'>
        <div class='col-lg-8 content'>
          <h1 class='mt-4'>Reading from the Command-Line in Kotlin</h1><h2 class='subtitle'>And how to make short work of complex problems using higher order functions, lambdas and generics</h2><div class='author'>
  <img src='/images/avatar_normal.jpg' alt='' srcset='/images/avatar_normal.jpg 1x, /images/avatar_retina.jpg 2x'/>
  <ul>
    <li>Sean Soper</li>
    <li>October 6, 2020</li>
  </ul>
</div><img class='img-fluid rounded' alt='' src='//source.unsplash.com/uZqJVqwFxMQ/900x300' srcset='//source.unsplash.com/uZqJVqwFxMQ/900x300 1x, //source.unsplash.com/uZqJVqwFxMQ/1800x600 2x'><p>When it comes to breaking down complex problems into smaller ones Kotlin offers a full range of functional tools and patterns to make your job easier. Building on our previous entry around <a href="/blog/creating_command_line_app_kotlin.html">building a command-line application</a> we will put several techniques to use to build a robust solution to the problem of accepting and validating user input.</p><h2>Parse with Class</h2><p>Let‚Äôs add a Kotlin class which we will be able to create instances of to parse our input. We‚Äôre going to call it the very originally named <code>CommandLineParser</code>. By bundling all of our parsing functionality into a single file we achieve two goals, <a href="https://en.wikipedia.org/wiki/Separation_of_concerns">separation of concerns</a> and <a href="https://en.wikipedia.org/wiki/Software_testability">testability</a>, both of which go a long ways towards ensuring ease of maintenance and extensability in the future.</p><p>Our parser will be pretty simple as it will accept only three arguments to start with: <code>help</code>, <code>verbose</code> and <code>config</code> the latter of which will be a string value pointing to a configuration file. However we will build it in such a way that if we wanted to add arguments that took integers as values it wouldn‚Äôt be difficult to do.</p><p>A summary of this new functionality, including the code highlighted below, can be found in <a href="https://github.com/ssoper/Batil/compare/9a3d6a5..8428dd6">these commits</a>.</p><h2>Data Class</h2><p>While Swift has the <code>struct</code>, Kotlin has the <code>data class</code>. They share a similar goal of providing a general-purpose flexible construct to store values. However they differ significantly in where they are stored. While a Swift <code>struct</code> is stored in the stack, a <code>data class</code>, being the object that it is, is stored in the heap along with every other reference type instance.</p><pre><code>
data class Parsed(val pathToConfigFile: Path,
                  val verbose: Boolean)
</code></pre><p>This class will provide us a means of encapsulating the parsed results of whatever command-line input was passed.</p><h2>Generics</h2><p><a href="https://kotlinlang.org/docs/reference/generics.html">Generics</a> are a means of allowing a function to return more than one type of value while also providing compile-time checks. An example of this would be a sorting function which can take two strings, two integers, etc. and return which one is greater. You could write a sorting function for each type <em>or</em> you could write one sorting function that simply takes two of the same type regardless of that type.</p><p>In our example we are using generics, noted by the <code>T</code> such as in <code>&lt;T: Any&gt;</code>, to ensure that the type of the value parsed out of the command-line input is what is returned. Without generics we would need to write a similar but different function that parsed integers for say a port number vs. parsing the path to a configuration file that would return a string.</p><pre><code>
private fun&lt;T: Any&gt; parseArguments(regex: Regex, transform: (String) -&gt; T): List&lt;T&gt; {
    val match = fun (str: String): T? {
        return regex.find(str)?.let {
            if (it.groups.count() &lt; 2) {
                return null
            }
            
            return it.groups[1]?.let {
                transform(it.value.removeSurrounding(&quot;\&quot;&quot;).removeSurrounding(&quot;'&quot;))
            }
        }
    }
    
    return args.mapNotNull(match)
}
</code></pre><h2>HOFs and Lambdas</h2><p>Higher Order Functions (HOFs) and lambdas are two sides of the same coin. HOFs are functions that can take functions as arguments. Lambdas are a type of function which can be passed as an argument to a HOF. Lambdas show up everywhere in functional programming but it should be noted they are <em>distinct</em> from <a href="https://gist.github.com/ericelliott/414be9be82128443f6df">anonymous functions</a>. So just like a sort function will  take a lambda as an expression to override the default sorting, our function will take a lambda to decide how to parse the input for that specific command-line argument.</p><pre><code>
private fun getPath(type: String): Path? {
    val regex = Regex(&quot;^-${type}=(.*)&quot;)
    
    return parseArguments(regex) {
        if (it.startsWith(&quot;/&quot;)) {
            Paths.get(it)
        } else {
            Paths.get(basePath, it)
        }
    }.firstOrNull()
}
</code></pre><p>In our case a typical value would be <code>-config=/path/to/config</code> along with a regular expression and the lambda. Most of the magic happens in <code>parseArguments</code> which uses the anonymous function stored in <code>match</code> to break the input up into logical parts which are then handed over to the lambda as a <code>List</code>. While it seems like overkill for parsing a <code>String</code>, it could just as easily be used to <a href="https://github.com/ssoper/Zebec/commit/76148c5d284e78d95116d0c527e74627f199dbcc#diff-ca1dfc769a491b093d314c64adf2b638R76">parse an integer</a>.</p><pre><code>
private fun getPort(): Int {
    val regex = Regex(&quot;^-port=(\\d{2,5})&quot;)
    return parseArguments(regex) {
      it.toInt()
    }.firstOrNull() ?: defaultPort
}
</code></pre><p>In this example the string values are being converted and returned as an <code>Int</code> while using the exact same code under the hood to break up the initial command-line input. That is the power of generics, HOFs and lambdas all working together to break down complexity into bite-sized reusable chunks.</p><h2>Integration</h2><p>Using this new parser functionality is pretty simple thanks to our componentized approach. Within <code>Core.kt</code> we need only update the <code>main</code> function to look like this.</p><pre><code>
@JvmStatic fun main(args: Array&lt;String&gt;) {
    val cli = CommandLineParser(args)
    
    if (cli.shouldShowHelp) {
        cli.showHelp()
        exitProcess(0)
    }
    
    val parsed = try {
        cli.parse()
    } catch (exception: ConfigFileNotFound) {
        println(&quot;‚ùå ${exception.localizedMessage}&quot;)
        cli.showHelp()
        exitProcess(1)
    }
    
    println(&quot;verbose set to ${parsed.verbose}&quot;)
    println(&quot;config path set to ${parsed.pathToConfigFile}&quot;)
}
</code></pre><p>Rebuilding the JAR file and running it should now produce useful output. Here it is showing the help dialog.</p><pre><code>
ssoper@rocinante Batil % java -jar out/artifacts/Batil_main_jar/Batil.main.jar -help
Arguments

    -help              Show documentation
    -verbose           Show debugging output
    -config=path       Path to configuration file, default is ./batil.config
</code></pre><p>Showing an error.</p><pre><code>
ssoper@rocinante Batil % java -jar out/artifacts/Batil_main_jar/Batil.main.jar -verbose
‚ùå Configuration file not found
Arguments

    -help              Show documentation
    -verbose           Show debugging output
    -config=path       Path to configuration file, default is ./batil.config
</code></pre><p>And finally showing a successful run.</p><pre><code>
ssoper@rocinante Batil % touch batil.config
ssoper@rocinante Batil % java -jar out/artifacts/Batil_main_jar/Batil.main.jar -verbose
verbose set to true
config path set to /Users/ssoper/workspace/Batil/batil.config
</code></pre><h2>Summary</h2><p>Of course, neither you or I are the first ones to stumble upon this problem which is why libraries such as <a href="https://ajalt.github.io/clikt/">Clikt</a> are available to use with your command-line applications should you not feel like building your own solution. Even if you do go with a pre-packaged command-line parser, there is plenty of opportunity to use the full range of functional tools provided by Kotlin to help reduce the complexity in your code.</p>
        </div>
        <!-- Sidebar Widgets Column -->
        <div class='col-md-4'>
          <!-- Search Widget -->
          <div class='card my-4'>
            <h5 class='card-header'>Search</h5>
            <div class='card-body'>
              <div class='input-group'>
                <input class='form-control' placeholder='Search for‚Ä¶' id='search-query' type='text' />
                <span class='input-group-btn'>
                  <button class='btn btn-secondary' type='button' id='search-button'>Go!</button>
                </span>
              </div>
            </div>
          </div>
          <a href='/blog/rss.xml'><img width='72' src='https://shields.io/badge/rss-2.0-blue?logo=rss'></a>
        </div>
      </div>
    </div>
    <!-- jQuery -->
    <script integrity='sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n' crossorigin='anonymous' src='https://code.jquery.com/jquery-3.4.1.slim.min.js'></script>
    <!-- Popper -->
    <script integrity='sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo' crossorigin='anonymous' src='https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js'></script>
    <!-- Bootstrap -->
    <script integrity='sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6' crossorigin='anonymous' src='https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js'></script>
    <!-- highlight.js -->
    <script src='//cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.18.0/build/highlight.min.js'></script>
    <!-- Delay loading of some assets for Google PageSpeed optimizations -->
    <noscript id='deferred-styles'>
      <link href='https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css' integrity='sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh' crossorigin='anonymous' rel='stylesheet' />
      <link href='/css/blog.min.css' rel='stylesheet' />
      <link href='//cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.18.0/build/styles/default.min.css' rel='stylesheet' />
    </noscript>
    <script src='/js/load_deferred_styles.min.js'></script>
    <script src='/js/load_highlight.min.js'></script>
    <script src='/js/load_search.min.js'></script>
    <!-- Google Analytics -->
    <script async src='https://www.googletagmanager.com/gtag/js?id=UA-616637-1'></script>
    <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'UA-616637-1');
    </script>
  </body>
</html>